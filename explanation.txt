אני לא עשיתי את הקוד בדיוק בצורה עם הxor אבל בשיטה שהשתמשתי בה אם היה נגיד פולינום שהיו בו יותר taps או שמספר הביטים היה גדול יותר אז הקוד הזה עדיף לפי דעתי.

בעצם שמתי כל ביט כאיבר בווקטור עמודה והכפלתי אותו במטריצה שעושה xor למיקומים של הtaps ומזיזה את כל שאר האיברים אחד קדימה, ואז החזרתי את הווקטור שיצא לייצוג של 32bits.

אם מה שעשיתי זה לא שיטה נכונה אז אפשר להשתמש בקוד הזה גם:
bit31 = (state >> 31) & 1
bit21 = (state >> 21) & 1
bit1 = (state >> 1) & 1
bit0 = state & 1
        
feedback_bit = bit31 ^ bit21 ^ bit1 ^ bit0

next_state = state >> 1

next_state = next_state | (feedback_bit << 31)
        
return next_state & 0xFFFFFFFF

אבל אני פשוט פחות הבנתי מה זה עושה אז העדפתי את השיטה שלי